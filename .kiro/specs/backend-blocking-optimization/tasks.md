# 实现计划：后端阻塞优化

## 概述

本实现计划将系统地优化 NeoView 后端的并发性能，减少阻塞操作，提升前端响应性。我们将分阶段进行，从最关键的优化开始，逐步覆盖所有组件。

## 任务

- [x] 1. 审计和分析现有锁使用情况
  - 扫描所有使用 `Mutex` 和 `RwLock` 的地方
  - 记录每个锁的持有时间和竞争情况
  - 识别高竞争的热点锁
  - _需求: 1.1, 1.2, 1.3_

- [-] 2. 优化 BookManager 锁策略
  - [ ] 2.1 将 `Mutex<BookManager>` 改为 `BookManager { state: Arc<RwLock<BookState>> }`
    - 创建 `BookState` 结构体包含可变状态
    - 修改 `BookManager` 方法使用读写锁
    - 更新所有命令处理函数的签名
    - _需求: 2.1, 2.2_

  - [-] 2.2 实现读操作的并发访问
    - `get_current_book` 使用读锁
    - `get_page_info` 使用读锁
    - 确保读操作不互相阻塞
    - _需求: 2.2, 2.4_

  - [ ] 2.3 编写 BookManager 并发测试
    - 测试多个读操作并发执行
    - 测试读写操作的正确性
    - 测试锁持有时间 < 1ms
    - _需求: 2.1, 2.4_

- [ ] 3. 优化 ImageLoader 锁策略
  - [ ] 3.1 评估 ImageLoader 是否需要锁
    - 检查 ImageLoader 的状态是否可变
    - 如果无状态，移除 Mutex 包装
    - 如果有状态，使用 RwLock
    - _需求: 2.3_

  - [ ] 3.2 更新命令处理函数
    - 修改 `load_image` 等命令的签名
    - 移除不必要的锁获取
    - _需求: 2.3_

- [ ] 4. 实现 PageManager 分片锁
  - [ ] 4.1 创建 MemoryPool 分片结构
    - 实现 `PoolShard` 结构体
    - 实现 `get_shard` 方法（基于哈希）
    - 设置分片数量为 CPU 核心数的 2 倍
    - _需求: 4.1, 4.4_

  - [ ] 4.2 重构 MemoryPool 方法
    - `get` 方法使用分片锁
    - `insert` 方法使用分片锁
    - `contains` 方法使用分片锁
    - _需求: 4.2_

  - [ ] 4.3 优化 `is_page_cached` 方法
    - 使用 `try_lock` 避免阻塞
    - 锁获取失败时返回 `false`
    - _需求: 4.1_

  - [ ] 4.4 编写分片锁并发测试
    - 测试不同分片可以并发访问
    - 测试相同分片的串行访问
    - 测试锁竞争减少
    - _需求: 4.4_

- [ ] 5. 异步化 I/O 操作
  - [ ] 5.1 异步化文件读取
    - 在 `load_page_data` 中使用 `spawn_blocking`
    - 在 `scan_directory` 中使用 `tokio::fs`
    - _需求: 3.1_

  - [ ] 5.2 异步化压缩包解压
    - 在 `ArchiveManager::load_image_from_archive_binary` 中使用 `spawn_blocking`
    - 确保不阻塞 Tokio 运行时
    - _需求: 3.2_

  - [ ] 5.3 异步化图像解码
    - 在 `generate_thumbnail_from_data` 中使用 `spawn_blocking`
    - 在 `get_image_dimensions` 中使用 `spawn_blocking`
    - _需求: 3.3_

  - [ ] 5.4 编写异步 I/O 测试
    - 测试大文件读取不阻塞运行时
    - 测试并发 I/O 操作
    - _需求: 3.1, 3.2, 3.3_

- [ ] 6. 优化 ArchiveManager 并发性
  - [ ] 6.1 使 ArchiveManager 可克隆
    - 移除 `Arc<Mutex<ArchiveManager>>` 包装
    - 实现 `Clone` trait
    - 每次调用时打开新的压缩包句柄
    - _需求: 5.1, 5.4_

  - [ ] 6.2 更新所有使用 ArchiveManager 的地方
    - 修改 `PageContentManager` 的 `archive_manager` 字段
    - 修改命令处理函数的签名
    - 移除锁获取代码
    - _需求: 5.1_

  - [ ] 6.3 编写并发解压测试
    - 测试多个线程同时解压不同文件
    - 测试性能提升
    - _需求: 5.1_

- [ ] 7. 实现请求去重机制
  - [ ] 7.1 创建 DedupMap 结构
    - 实现 `DedupMap<K, V>` 泛型结构
    - 实现 `get_or_load` 方法
    - 使用 `oneshot` channel 通知等待者
    - _需求: 9.1, 9.2, 9.3_

  - [ ] 7.2 在 PageManager 中集成 DedupMap
    - 在 `goto_page` 中使用去重
    - 在 `get_page` 中使用去重
    - _需求: 9.1_

  - [ ] 7.3 编写请求去重测试
    - 测试重复请求只执行一次
    - 测试所有等待者都收到结果
    - 测试失败后可以重试
    - _需求: 9.1, 9.2, 9.3, 9.4_

- [ ] 8. 优化缩略图服务
  - [ ] 8.1 确认并行生成已实现
    - 检查 `pm_preload_thumbnails` 是否使用 Rayon
    - 确认并行度设置正确
    - _需求: 6.1_

  - [ ] 8.2 实现优先级调度
    - 按距离中心排序（已实现）
    - 添加可见区域优先级
    - _需求: 6.2_

  - [ ] 8.3 实现任务取消
    - 在切换书籍时取消旧任务
    - 使用 `CancellationToken`
    - _需求: 6.3_

  - [ ] 8.4 编写缩略图性能测试
    - 测试并行生成速度
    - 测试任务取消及时性
    - _需求: 6.1, 6.3_

- [ ] 9. 优化放大服务
  - [ ] 9.1 限制并发放大任务数量
    - 使用 `Semaphore` 限制并发数
    - 设置为 CPU 核心数
    - _需求: 7.1_

  - [ ] 9.2 实现任务取消
    - 在切换页面时取消不需要的任务
    - 快速释放资源
    - _需求: 7.2, 7.4_

  - [ ] 9.3 优化队列调度
    - 实现优先级队列（已部分实现）
    - 确保当前页优先
    - _需求: 7.3_

  - [ ] 9.4 编写放大服务测试
    - 测试并发限制
    - 测试任务取消
    - _需求: 7.1, 7.2_

- [ ] 10. 优化数据库操作
  - [ ] 10.1 评估数据库锁竞争
    - 分析 `ThumbnailDb` 的锁使用
    - 测量锁持有时间
    - _需求: 8.1, 8.2_

  - [ ] 10.2 实现连接池（可选）
    - 如果锁竞争严重，使用 r2d2
    - 配置连接池大小
    - _需求: 8.1_

  - [ ] 10.3 优化批量操作
    - 使用事务批量插入
    - 减少锁获取次数
    - _需求: 8.2_

  - [ ] 10.4 编写数据库并发测试
    - 测试并发读写
    - 测试性能提升
    - _需求: 8.1, 8.3_

- [ ] 11. 添加性能监控
  - [ ] 11.1 添加锁持有时间监控
    - 使用 `tracing` 记录锁获取和释放
    - 记录持有时间超过 1ms 的锁
    - _需求: 10.2_

  - [ ] 11.2 添加命令执行时间监控
    - 在所有命令处理函数中添加计时
    - 记录执行时间超过 100ms 的命令
    - _需求: 10.1_

  - [ ] 11.3 添加任务队列监控
    - 记录 Job Engine 的队列长度
    - 记录任务等待时间
    - _需求: 10.3_

  - [ ] 11.4 实现性能诊断接口
    - 添加 `get_performance_stats` 命令
    - 返回锁竞争、队列长度等信息
    - _需求: 10.4_

- [ ] 12. 检查点 - 运行所有测试
  - 确保所有单元测试通过
  - 运行集成测试
  - 运行性能基准测试
  - 如有问题，询问用户

- [ ] 13. 性能验证和调优
  - [ ] 13.1 运行性能基准测试
    - 测量优化前后的响应时间
    - 测量并发吞吐量
    - 记录性能提升百分比
    - _需求: 所有_

  - [ ] 13.2 分析性能瓶颈
    - 使用 profiler 分析热点
    - 识别剩余的阻塞操作
    - _需求: 所有_

  - [ ] 13.3 进一步优化
    - 根据分析结果调整参数
    - 优化剩余瓶颈
    - _需求: 所有_

- [ ] 14. 文档更新
  - 更新架构文档
  - 更新 API 文档
  - 添加性能优化指南

## 注意事项

- 所有任务都是必需的，包括测试任务
- 每个任务都引用了相关的需求编号
- 建议按顺序执行任务，因为后续任务可能依赖前面的改动
- 在每个检查点停下来，确保所有测试通过
- 性能优化是渐进式的，不要期望一次性解决所有问题
