# NeoView 加载速度测试流程

## 目标

- 普通图片（文件夹/单文件）在超大文件场景下避免 IPC 传输与内存拷贝
- 压缩包图片在超大条目场景下避免一次性解压到内存
- 形成可复用的“速度回归”流程：可测、可比、可复现

## 准备测试数据

### 1) 超大图片文件（建议 600MB）

- 复制一张真实的大图到测试目录
- 或用“稀疏文件”模拟体积（用于验证不走读入/IPC 的路径）：
  - Windows PowerShell：
    - `fsutil file createnew D:\bench\big.bin 644245094`

### 2) 压缩包大条目（建议 300MB+）

- 准备一个 zip/7z，包含一张大图或大二进制文件条目

## 运行与采样

### 前端采样（推荐）

- 启动开发模式：`npm run dev`
- 打开书籍后，在界面里关注：
  - 翻页控制台日志（翻页延迟 warning）
  - 性能面板/信息面板中的 pipeline 记录（来源、耗时、是否走 URL 直连）

### 后端回归（自动化）

- 运行 Rust 单元测试：
  - `cargo test -p neoview`
- 关键测试点：
  - zip 条目解压到文件路径的 roundtrip 测试（避免必须把条目读成 Vec）

## 回归基线建议

- 大文件（>500MB）目标：
  - 首次切页不再触发 `pm_get_page` / `pm_goto_page` 的 ArrayBuffer 传输
  - 目标是 UI 快速显示（`asset://` / `neoview://` URL 直连），避免峰值内存暴涨

## 常见误区

- 对超大文件继续走 `invoke -> ArrayBuffer -> Blob -> objectURL` 会产生双倍以上峰值内存
- “临时文件模式”如果仍把数据先读入 Vec 再写文件，峰值内存依旧很高
