# Viewer 架构方案对比

## 问题背景

当前 Viewer 存在的问题：
1. **翻页闪屏** - 切换页面时需要重新加载图片，导致短暂空白
2. **缓存管理复杂** - 需要手动管理 Blob URL 缓存
3. **状态同步困难** - 旧系统和新系统数据流不一致

## 方案对比

### 方案 A: 层叠式 (Stack-based)

```
┌─────────────────────────────────────────┐
│              Viewer Container            │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐    │
│  │     Layer 4: 超分层 (可选)       │    │  z-index: 4
│  │     - 超分后的图片               │    │
│  │     - 覆盖在原图上               │    │
│  └─────────────────────────────────┘    │
│  ┌─────────────────────────────────┐    │
│  │     Layer 3: 当前页 (可见)       │    │  z-index: 3
│  │     - 当前显示的页面             │    │
│  └─────────────────────────────────┘    │
│  ┌─────────────────────────────────┐    │
│  │     Layer 2: 后页 (预加载)       │    │  z-index: 2, opacity: 0
│  │     - 下一页，已加载但隐藏       │    │
│  └─────────────────────────────────┘    │
│  ┌─────────────────────────────────┐    │
│  │     Layer 1: 前页 (预加载)       │    │  z-index: 1, opacity: 0
│  │     - 上一页，已加载但隐藏       │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**优点：**
- ✅ **无闪屏** - 图片已预加载，切换只需改变 z-index/opacity
- ✅ **简单缓存** - 浏览器自动管理 img 元素的缓存
- ✅ **平滑过渡** - 可以添加 CSS 动画实现滑动/淡入效果
- ✅ **超分无缝** - 超分层覆盖在原图上，完成后直接显示

**缺点：**
- ❌ **内存占用** - 同时保持多个 img 元素在 DOM 中
- ❌ **DOM 复杂** - 需要管理多个层的状态
- ❌ **双页模式** - 需要额外处理双页布局

**实现复杂度：** ⭐⭐⭐ (中等)

---

### 方案 B: 单图替换式 (Current)

```
┌─────────────────────────────────────────┐
│              Viewer Container            │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐    │
│  │     Single Image Element         │    │
│  │     - src 切换时重新加载         │    │
│  └─────────────────────────────────┘    │
│                                         │
│  [Blob Cache] ← 手动管理缓存            │
│    - page_0: blob:xxx                   │
│    - page_1: blob:xxx                   │
│    - page_2: blob:xxx                   │
└─────────────────────────────────────────┘
```

**优点：**
- ✅ **DOM 简单** - 只有一个 img 元素
- ✅ **内存可控** - 可以精确控制缓存大小

**缺点：**
- ❌ **闪屏** - 切换 src 时有短暂空白
- ❌ **缓存复杂** - 需要手动管理 Blob URL 生命周期
- ❌ **无动画** - 难以实现平滑过渡

**实现复杂度：** ⭐⭐ (简单)

---

### 方案 C: 虚拟列表式 (Virtual List)

```
┌─────────────────────────────────────────┐
│              Viewer Container            │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐    │
│  │     Virtual Scroll Container     │    │
│  │                                  │    │
│  │  [Page -1] [Page 0] [Page 1]    │    │  ← 只渲染可见区域
│  │            ↑ 当前               │    │
│  │                                  │    │
│  └─────────────────────────────────┘    │
│                                         │
│  滚动/滑动切换页面                       │
└─────────────────────────────────────────┘
```

**优点：**
- ✅ **无闪屏** - 相邻页面已在 DOM 中
- ✅ **自然交互** - 支持滑动手势
- ✅ **内存高效** - 只渲染可见区域

**缺点：**
- ❌ **实现复杂** - 需要虚拟滚动库
- ❌ **缩放困难** - 缩放时滚动行为复杂
- ❌ **双页模式** - 需要特殊处理

**实现复杂度：** ⭐⭐⭐⭐ (复杂)

---

### 方案 D: Canvas 渲染式

```
┌─────────────────────────────────────────┐
│              Viewer Container            │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐    │
│  │         Canvas Element           │    │
│  │                                  │    │
│  │  drawImage(currentPage)          │    │
│  │  drawImage(upscaledPage)         │    │  ← 直接绘制
│  │                                  │    │
│  └─────────────────────────────────┘    │
│                                         │
│  [Image Cache] ← ImageBitmap 缓存       │
└─────────────────────────────────────────┘
```

**优点：**
- ✅ **高性能** - GPU 加速渲染
- ✅ **精确控制** - 可以精确控制每个像素
- ✅ **无闪屏** - 预加载 ImageBitmap 后直接绘制

**缺点：**
- ❌ **实现复杂** - 需要手动处理所有渲染逻辑
- ❌ **无 CSS** - 不能使用 CSS 动画
- ❌ **调试困难** - 不能用 DevTools 检查

**实现复杂度：** ⭐⭐⭐⭐⭐ (非常复杂)

---

## 推荐方案

### 🏆 方案 A: 层叠式 (推荐)

**理由：**
1. **解决核心问题** - 无闪屏，这是用户最关心的
2. **实现简单** - 只需要管理几个 img 元素的显示/隐藏
3. **易于扩展** - 超分层、动画都很容易添加
4. **浏览器友好** - 利用浏览器的图片缓存机制

**实现要点：**

```svelte
<div class="viewer-stack">
  <!-- 前页层 -->
  <img 
    src={prevPageUrl} 
    class="layer prev-layer"
    class:visible={showPrev}
    style="z-index: 1"
  />
  
  <!-- 当前页层 -->
  <img 
    src={currentPageUrl} 
    class="layer current-layer"
    style="z-index: 3"
  />
  
  <!-- 后页层 -->
  <img 
    src={nextPageUrl} 
    class="layer next-layer"
    class:visible={showNext}
    style="z-index: 2"
  />
  
  <!-- 超分层 -->
  {#if upscaledUrl}
    <img 
      src={upscaledUrl} 
      class="layer upscale-layer"
      style="z-index: 4"
    />
  {/if}
</div>

<style>
  .layer {
    position: absolute;
    inset: 0;
    object-fit: contain;
    opacity: 0;
    transition: opacity 0.2s ease;
  }
  
  .current-layer {
    opacity: 1;
  }
  
  .visible {
    opacity: 1;
  }
</style>
```

**翻页逻辑：**

```typescript
function nextPage() {
  // 1. 当前页变成前页
  prevPageUrl = currentPageUrl;
  
  // 2. 后页变成当前页
  currentPageUrl = nextPageUrl;
  
  // 3. 预加载新的后页
  nextPageUrl = await loadPage(currentIndex + 1);
}
```

---

## 阅读方向处理

| 模式 | LTR (左到右) | RTL (右到左) |
|------|-------------|-------------|
| 单页 | 前页在左，后页在右 | 前页在右，后页在左 |
| 双页 | 左页在左，右页在右 | 左页在右，右页在左 |
| 全景 | 从左向右滚动 | 从右向左滚动 |

层叠式只需要在翻页时调整层的位置即可。

---

## 下一步

1. 创建 `StackViewer.svelte` 组件
2. 实现三层预加载逻辑
3. 添加超分层支持
4. 添加翻页动画
5. 集成到 ImageViewer
