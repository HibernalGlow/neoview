//! Thumbnail Database Module
//! ç¼©ç•¥å›¾æ•°æ®åº“æ¨¡å— - å‚è€ƒ NeeView çš„å®ç°
//! ä½¿ç”¨ SQLite å­˜å‚¨ webp æ ¼å¼çš„ç¼©ç•¥å›¾ blob

use chrono::{Duration, Local};
use rusqlite::{params, Connection, Result as SqliteResult};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

/// ç¼©ç•¥å›¾æ•°æ®åº“ç®¡ç†å™¨
pub struct ThumbnailDb {
    connection: Arc<Mutex<Option<Connection>>>,
    db_path: PathBuf,
}

#[derive(Debug, Clone)]
pub struct ThumbnailDbStats {
    pub total_entries: i64,
    pub file_entries: i64,
    pub folder_entries: i64,
    pub total_size_bytes: i64,
    pub oldest_entry: Option<String>,
    pub newest_entry: Option<String>,
    pub database_size_bytes: u64,
}

#[derive(Debug)]
pub struct ThumbnailDbRecord {
    pub key: String,
    pub category: String,
    pub blob: Option<Vec<u8>>,
}

impl ThumbnailDb {
    /// åˆ›å»ºæ–°çš„ç¼©ç•¥å›¾æ•°æ®åº“ç®¡ç†å™¨
    pub fn new(db_path: PathBuf) -> Self {
        Self {
            connection: Arc::new(Mutex::new(None)),
            db_path,
        }
    }

    /// æ‰“å¼€æ•°æ®åº“è¿æ¥ï¼ˆå‡å°‘æ—¥å¿—è¾“å‡ºï¼Œé¿å…é¢‘ç¹æ£€æŸ¥ï¼‰
    fn open(&self) -> SqliteResult<()> {
        let mut conn_opt = self.connection.lock().unwrap();

        if conn_opt.is_some() {
            // è¿æ¥å·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›ï¼ˆä¸æ‰“å°æ—¥å¿—ï¼Œå‡å°‘è¾“å‡ºï¼‰
            return Ok(());
        }

        // åªåœ¨é¦–æ¬¡æ‰“å¼€æ—¶æ‰“å°æ—¥å¿—
        println!("ğŸ”“ é¦–æ¬¡æ‰“å¼€æ•°æ®åº“è¿æ¥: {}", self.db_path.display());

        // åˆ›å»ºæ•°æ®åº“ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
        if let Some(parent) = self.db_path.parent() {
            if let Err(e) = std::fs::create_dir_all(parent) {
                eprintln!("âŒ åˆ›å»ºæ•°æ®åº“ç›®å½•å¤±è´¥: {} - {}", parent.display(), e);
                return Err(rusqlite::Error::SqliteFailure(
                    rusqlite::ffi::Error::new(rusqlite::ffi::SQLITE_CANTOPEN),
                    Some(format!("åˆ›å»ºæ•°æ®åº“ç›®å½•å¤±è´¥: {}", e)),
                ));
            }
        }

        let conn = match Connection::open(&self.db_path) {
            Ok(c) => c,
            Err(e) => {
                eprintln!("âŒ æ•°æ®åº“è¿æ¥æ‰“å¼€å¤±è´¥: {} - {}", self.db_path.display(), e);
                return Err(e);
            }
        };

        // åˆå§‹åŒ–æ•°æ®åº“
        match Self::initialize_db(&conn) {
            Ok(_) => {}
            Err(e) => {
                eprintln!("âŒ æ•°æ®åº“è¡¨ç»“æ„åˆå§‹åŒ–å¤±è´¥: {}", e);
                return Err(e);
            }
        }

        *conn_opt = Some(conn);
        println!("âœ… æ•°æ®åº“è¿æ¥å·²åˆå§‹åŒ–");
        Ok(())
    }

    /// åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„
    fn initialize_db(conn: &Connection) -> SqliteResult<()> {
        // è®¾ç½® PRAGMAï¼ˆä½¿ç”¨ execute_batch é¿å…è¿”å›å€¼é—®é¢˜ï¼‰
        conn.execute_batch(
            "PRAGMA auto_vacuum = FULL;
             PRAGMA journal_mode = WAL;
             PRAGMA synchronous = NORMAL;",
        )?;

        // åˆ›å»ºç¼©ç•¥å›¾è¡¨
        conn.execute(
            "CREATE TABLE IF NOT EXISTS thumbs (
                key TEXT NOT NULL PRIMARY KEY,
                size INTEGER,
                date TEXT,
                ghash INTEGER,
                category TEXT DEFAULT 'file',
                value BLOB
            )",
            [],
        )?;
        // åˆ›å»ºç´¢å¼•ä»¥æé«˜æŸ¥è¯¢æ€§èƒ½
        conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_thumbs_key ON thumbs(key)",
            [],
        )?;
        conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_thumbs_category ON thumbs(category)",
            [],
        )?;
        conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_thumbs_date ON thumbs(date)",
            [],
        )?;

        Ok(())
    }

    /// è·å–å½“å‰æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
    fn current_timestamp_string() -> String {
        Local::now().format("%Y-%m-%d %H:%M:%S").to_string()
    }

    /// ä¿å­˜ç¼©ç•¥å›¾ï¼ˆå‡å°‘æ—¥å¿—è¾“å‡ºï¼‰
    pub fn save_thumbnail(
        &self,
        key: &str,
        size: i64,
        ghash: i32,
        thumbnail_data: &[u8],
    ) -> SqliteResult<()> {
        self.save_thumbnail_with_category(key, size, ghash, thumbnail_data, None)
    }

    /// ä¿å­˜ç¼©ç•¥å›¾ï¼ˆå¸¦ç±»åˆ«ï¼‰
    pub fn save_thumbnail_with_category(
        &self,
        key: &str,
        size: i64,
        ghash: i32,
        thumbnail_data: &[u8],
        category: Option<&str>,
    ) -> SqliteResult<()> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        let date = Self::current_timestamp_string();

        // è‡ªåŠ¨åˆ¤æ–­ç±»åˆ«ï¼šå¦‚æœæ²¡æœ‰æ‰©å±•åä¸”ä¸æ˜¯å‹ç¼©åŒ…å†…éƒ¨è·¯å¾„ï¼Œåˆ™ä¸ºæ–‡ä»¶å¤¹
        let cat = category.unwrap_or_else(|| {
            if !key.contains("::") && !key.contains(".") {
                "folder"
            } else {
                "file"
            }
        });

        // ä½¿ç”¨ prepare + execute é¿å… "Execute returned results" é”™è¯¯
        let mut stmt = conn.prepare(
            "INSERT OR REPLACE INTO thumbs (key, size, date, ghash, category, value) VALUES (?1, ?2, ?3, ?4, ?5, ?6)"
        )?;

        // execute è¿”å›å—å½±å“çš„è¡Œæ•°
        let _rows_affected = stmt.execute(params![key, size, date, ghash, cat, thumbnail_data])?;

        // é‡Šæ”¾è¯­å¥ï¼Œç¡®ä¿æ•°æ®å·²å†™å…¥
        drop(stmt);

        // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ‰“å°æ—¥å¿—
        if cfg!(debug_assertions) {
            println!(
                "âœ… ç¼©ç•¥å›¾å·²ä¿å­˜åˆ°æ•°æ®åº“: key={}, category={}, size={} bytes",
                key,
                cat,
                thumbnail_data.len()
            );
        }

        Ok(())
    }

    /// åŠ è½½ç¼©ç•¥å›¾ï¼ˆå‡å°‘æ—¥å¿—è¾“å‡ºï¼‰
    pub fn load_thumbnail(
        &self,
        key: &str,
        size: i64,
        ghash: i32,
    ) -> SqliteResult<Option<Vec<u8>>> {
        self.load_thumbnail_with_category(key, size, ghash, None)
    }

    /// åŠ è½½ç¼©ç•¥å›¾ï¼ˆä»…æ ¹æ® key å’Œ categoryï¼Œå¿½ç•¥ size å’Œ ghashï¼Œå‡å°‘è®¡ç®—ï¼‰
    /// è¿™æ˜¯é»˜è®¤çš„æŸ¥è¯¢æ–¹å¼ï¼Œé€‚ç”¨äºæ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹
    pub fn load_thumbnail_by_key_and_category(
        &self,
        key: &str,
        category: &str,
    ) -> SqliteResult<Option<Vec<u8>>> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        let mut stmt =
            conn.prepare("SELECT value FROM thumbs WHERE key = ?1 AND category = ?2 LIMIT 1")?;

        let mut rows =
            stmt.query_map(params![key, category], |row| Ok(row.get::<_, Vec<u8>>(0)?))?;

        if let Some(row) = rows.next() {
            let data = row?;
            if cfg!(debug_assertions) {
                println!(
                    "âœ… ä»æ•°æ®åº“åŠ è½½ç¼©ç•¥å›¾ï¼ˆkey+categoryï¼‰: key={}, category={}, size={} bytes",
                    key,
                    category,
                    data.len()
                );
            }
            Ok(Some(data))
        } else {
            if cfg!(debug_assertions) {
                println!(
                    "ğŸ“­ æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ç¼©ç•¥å›¾ï¼ˆkey+categoryï¼‰: key={}, category={}",
                    key, category
                );
            }
            Ok(None)
        }
    }

    /// æŸ¥æ‰¾è·¯å¾„ä¸‹æœ€æ—©çš„ç¼©ç•¥å›¾è®°å½•ï¼ˆç”¨äºæ–‡ä»¶å¤¹ç»‘å®šï¼‰
    /// æŸ¥æ‰¾æ‰€æœ‰ä»¥ folder_path/ æˆ– folder_path\ å¼€å¤´çš„ keyï¼Œè¿”å›æœ€æ—©çš„è®°å½•
    pub fn find_earliest_thumbnail_in_path(
        &self,
        folder_path: &str,
    ) -> SqliteResult<Option<(String, Vec<u8>)>> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        // æŸ¥æ‰¾æ‰€æœ‰ä»¥ folder_path/ æˆ– folder_path\ å¼€å¤´çš„è®°å½•ï¼ŒæŒ‰ date æ’åºï¼Œå–æœ€æ—©çš„
        // åªæŸ¥æ‰¾æ–‡ä»¶ï¼ˆcategory='file'ï¼‰ï¼Œä¸æŸ¥æ‰¾æ–‡ä»¶å¤¹
        // ä½¿ç”¨ OR æ¡ä»¶åŒ¹é…ä¸¤ç§è·¯å¾„åˆ†éš”ç¬¦
        let search_pattern1 = format!("{}/%", folder_path);
        let search_pattern2 = format!("{}\\{}", folder_path, "%");
        let mut stmt = conn.prepare(
            "SELECT key, value, date FROM thumbs WHERE (key LIKE ?1 OR key LIKE ?2) AND category = 'file' ORDER BY date ASC LIMIT 1"
        )?;

        let mut rows = stmt.query_map(params![search_pattern1, search_pattern2], |row| {
            let key: String = row.get(0)?;
            let value: Vec<u8> = row.get(1)?;
            Ok((key, value))
        })?;

        if let Some(row) = rows.next() {
            let result = row?;
            if cfg!(debug_assertions) {
                println!("ğŸ” æ‰¾åˆ°è·¯å¾„ä¸‹æœ€æ—©çš„ç¼©ç•¥å›¾: {}", result.0);
            }
            Ok(Some(result))
        } else {
            if cfg!(debug_assertions) {
                println!("ğŸ“­ è·¯å¾„ä¸‹æ²¡æœ‰æ‰¾åˆ°ç¼©ç•¥å›¾: {}", folder_path);
            }
            Ok(None)
        }
    }

    /// åŠ è½½ç¼©ç•¥å›¾ï¼ˆå¸¦ç±»åˆ«è¿‡æ»¤ï¼‰
    pub fn load_thumbnail_with_category(
        &self,
        key: &str,
        size: i64,
        ghash: i32,
        category: Option<&str>,
    ) -> SqliteResult<Option<Vec<u8>>> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        // å¦‚æœæŒ‡å®šäº†ç±»åˆ«ï¼Œåªåœ¨å¯¹åº”ç±»åˆ«ä¸­æœç´¢
        let result = if let Some(cat) = category {
            let mut stmt = conn.prepare(
                "SELECT value FROM thumbs WHERE key = ?1 AND size = ?2 AND ghash = ?3 AND category = ?4"
            )?;
            let mut rows = stmt.query_map(params![key, size, ghash, cat], |row| {
                Ok(row.get::<_, Vec<u8>>(0)?)
            })?;
            rows.next().transpose()
        } else {
            let mut stmt = conn
                .prepare("SELECT value FROM thumbs WHERE key = ?1 AND size = ?2 AND ghash = ?3")?;
            let mut rows = stmt.query_map(params![key, size, ghash], |row| {
                Ok(row.get::<_, Vec<u8>>(0)?)
            })?;
            rows.next().transpose()
        };

        match result {
            Ok(Some(data)) => {
                // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ‰“å°æ—¥å¿—
                if cfg!(debug_assertions) {
                    println!(
                        "âœ… ä»æ•°æ®åº“åŠ è½½ç¼©ç•¥å›¾: key={}, category={:?}, size={} bytes",
                        key,
                        category,
                        data.len()
                    );
                }
                Ok(Some(data))
            }
            Ok(None) => {
                // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹æ‰“å°æ—¥å¿—
                if cfg!(debug_assertions) {
                    println!(
                        "ğŸ“­ æ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°ç¼©ç•¥å›¾: key={}, category={:?}",
                        key, category
                    );
                }
                Ok(None)
            }
            Err(e) => Err(e),
        }
    }

    /// æ‰¹é‡åŠ è½½ç¼©ç•¥å›¾ï¼ˆç”¨äºé¢„åŠ è½½ç´¢å¼•ï¼‰
    pub fn batch_load_thumbnails(&self, keys: &[String]) -> SqliteResult<Vec<(String, Vec<u8>)>> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();
        let mut results = Vec::new();

        for key in keys {
            let mut stmt = conn.prepare("SELECT value FROM thumbs WHERE key = ?1")?;

            let mut rows = stmt.query_map([key], |row| Ok(row.get::<_, Vec<u8>>(0)?))?;

            if let Some(row) = rows.next() {
                if let Ok(data) = row {
                    results.push((key.clone(), data));
                }
            }
        }

        Ok(results)
    }

    /// æ£€æŸ¥ç¼©ç•¥å›¾æ˜¯å¦å­˜åœ¨ï¼ˆä»… key + categoryï¼Œå‡å°‘è®¡ç®—ï¼‰
    /// è¿™æ˜¯é»˜è®¤çš„æ£€æŸ¥æ–¹å¼ï¼Œé€‚ç”¨äºæ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹
    pub fn has_thumbnail_by_key_and_category(
        &self,
        key: &str,
        category: &str,
    ) -> SqliteResult<bool> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        let mut stmt =
            conn.prepare("SELECT 1 FROM thumbs WHERE key = ?1 AND category = ?2 LIMIT 1")?;

        let exists = stmt.exists(params![key, category])?;
        Ok(exists)
    }

    /// æ£€æŸ¥ç¼©ç•¥å›¾æ˜¯å¦å­˜åœ¨ï¼ˆä¿ç•™ä»¥å…¼å®¹æ—§ä»£ç ï¼‰
    pub fn has_thumbnail(&self, key: &str, _size: i64, _ghash: i32) -> SqliteResult<bool> {
        // è‡ªåŠ¨åˆ¤æ–­ç±»åˆ«
        let category = if !key.contains("::") && !key.contains(".") {
            "folder"
        } else {
            "file"
        };
        self.has_thumbnail_by_key_and_category(key, category)
    }

    /// æ£€æŸ¥ç¼©ç•¥å›¾æ˜¯å¦å­˜åœ¨ï¼ˆå¸¦ç±»åˆ«è¿‡æ»¤ï¼Œä¿ç•™ä»¥å…¼å®¹æ—§ä»£ç ï¼‰
    pub fn has_thumbnail_with_category(
        &self,
        key: &str,
        _size: i64,
        _ghash: i32,
        category: Option<&str>,
    ) -> SqliteResult<bool> {
        let cat = category.unwrap_or_else(|| {
            if !key.contains("::") && !key.contains(".") {
                "folder"
            } else {
                "file"
            }
        });
        self.has_thumbnail_by_key_and_category(key, cat)
    }

    /// æ›´æ–°è®¿é—®æ—¶é—´
    pub fn update_access_time(&self, key: &str) -> SqliteResult<()> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();
        let date = Self::current_timestamp_string();

        conn.execute(
            "UPDATE thumbs SET date = ?1 WHERE key = ?2",
            params![date, key],
        )?;

        Ok(())
    }

    /// åˆ é™¤æ—§çš„ç¼©ç•¥å›¾ï¼ˆåŸºäºæ—¶é—´ï¼‰
    pub fn delete_old_thumbnails(&self, days: i64) -> SqliteResult<usize> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();
        let cutoff_time = Local::now() - Duration::days(days);
        let cutoff = cutoff_time.format("%Y-%m-%d %H:%M:%S").to_string();

        let count = conn.execute("DELETE FROM thumbs WHERE date < ?1", params![cutoff])?;

        Ok(count)
    }

    /// æ¸…ç†æ•°æ®åº“ï¼ˆVACUUMï¼‰
    pub fn vacuum(&self) -> SqliteResult<()> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();
        conn.execute("VACUUM", [])?;
        Ok(())
    }

    /// è·å–æ•°æ®åº“å¤§å°
    pub fn get_database_size(&self) -> SqliteResult<u64> {
        if self.db_path.exists() {
            std::fs::metadata(&self.db_path)
                .map(|m| m.len())
                .map_err(|e| {
                    rusqlite::Error::SqliteFailure(
                        rusqlite::ffi::Error::new(rusqlite::ffi::SQLITE_IOERR),
                        Some(format!("Failed to get file metadata: {}", e)),
                    )
                })
        } else {
            Ok(0)
        }
    }

    /// è·å–ç›®å½•ä¸‹æ‰€æœ‰ç¼“å­˜çš„ç¼©ç•¥å›¾ï¼ˆç”¨äºå¯åŠ¨é¢„åŠ è½½ï¼‰
    pub fn get_thumbnails_by_directory(&self, directory: &str) -> SqliteResult<Vec<crate::commands::thumbnail_commands::ThumbnailEntry>> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();

        // è§„èŒƒåŒ–ç›®å½•è·¯å¾„ï¼ˆç¡®ä¿ä»¥ / æˆ– \ ç»“å°¾ç”¨äº LIKE åŒ¹é…ï¼‰
        let dir_pattern = if directory.ends_with('/') || directory.ends_with('\\') {
            format!("{}%", directory)
        } else {
            format!("{}%", directory)
        };

        let mut stmt = conn.prepare(
            "SELECT key, value FROM thumbs WHERE key LIKE ?1"
        )?;

        let rows = stmt.query_map([&dir_pattern], |row| {
            Ok(crate::commands::thumbnail_commands::ThumbnailEntry {
                path: row.get(0)?,
                data: row.get(1)?,
            })
        })?;

        let mut results = Vec::new();
        for row in rows {
            if let Ok(entry) = row {
                results.push(entry);
            }
        }

        Ok(results)
    }

    /// åˆ é™¤ç¼©ç•¥å›¾
    pub fn delete_thumbnail(&self, key: &str) -> SqliteResult<()> {
        self.open()?;
        let conn_guard = self.connection.lock().unwrap();
        let conn = conn_guard.as_ref().unwrap();
        conn.execute("DELETE FROM thumbs WHERE key = ?1", [key])?;
        Ok(())
    }
}

impl Clone for ThumbnailDb {
    fn clone(&self) -> Self {
        Self {
            connection: Arc::clone(&self.connection),
            db_path: self.db_path.clone(),
        }
    }
}
